1. 简单理解解释器的作用方式--代换模型
   
   > 将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。
   > 
   > 这里的代换模型只是这些模型中的第一个一一作为形式化地考虑这种求值过程的起点。一般来说，在模拟科学研究或者工程中的现象时，我们总是从最简单的不完全的模型开始。随着更细致地检查所考虑的问题，这些简单模型也会变得越来越不合适，从而必须用进一步精化的模型取代。

2. 两种求值模型--正则序求值/应用序求值
   
   > “完全展开而后归约”的求值模型称为正则序求值，与之对应的是现在解释器里实际使用的“先求值参数而后应用”的方式，它称为应用序求值。

3. Lisp命名规范--函数命名时用`-`划分
   
   > 给Scheme函数命名使用-划分的原因有以下几点:
   > 
   > 1. Scheme语言对标识符的命名非常灵活,允许使用特殊字符如-。
   > 2. Lisp家族语言fromString建议用-而不是_来连接多词标识符。
   > 3. -比_更容易辨认,a-plus-b比a_plus_b更易读。
   > 4. Scheme本身语法就包含-,如define-syntax。
   > 5. 使用-符合Scheme、Lisp传统和习惯。

4. 线性迭代--只维护有限数量的状态
   
   > ```scheme
   > (define (fib n)
   >   (fib-iter 1 0 n))
   > 
   > (define (fib-iter a b count)
   >   (if (= count 0)
   >       b
   >       (fib-iter (+ a b) a (- count 1))))
   > ```
   > 
   > 为什么这个代码中的 `fib-iter` 函数被称为线性迭代：
   > 
   > 1. `fib-iter` 函数是一个带有三个参数的迭代函数，其中 `a` 和 `b` 分别表示斐波那契数列的前两个元素，`count` 表示还需要计算多少个斐波那契数。
   > 
   > 2. 在每次迭代中，`fib-iter` 函数计算下一个斐波那契数（`a + b`），并将 `a` 更新为之前的 `b`，将 `b` 更新为之前的计算结果。这就是为什么它被称为线性迭代，因为它在每次迭代中只需要维护两个状态（`a` 和 `b`），而不需要创建额外的递归调用堆栈。
   > 
   > 3. 当 `count` 减小到零时，迭代停止，返回最终的结果 `b`。这是一个迭代终止条件。
   > 
   > 所以，尽管 `fib-iter` 函数使用了函数递归（在每次迭代中调用自己），但它被称为线性迭代，因为它只维护了有限数量的状态，而没有创建大量的递归函数调用帧，这符合线性迭代的特性。这种方法通常比直接使用递归更有效率，因为不需要大量的函数调用开销。

5. 运行时间、步数和算法复杂度
   
   > 通过对三个版本的 search-for-primes 进行测试，我们发现，使用算法复杂度或者计算步数并不能完全预测程序的运行时间。
   > 
   > 首先，即使我们能准确地计算出程序所需的步数，程序的运行速度还是会受到其他条件的影响，比如计算机的快慢，系统资源的占用情况，或者编译器/解释器的优化程度，等等，即使是同样的一个程序，在不同情况下运行速度也会有所不同，所以程序的计算步数能对程序的运行状况给出有用的参考信息，但是它没办法、也不可能完全准确预测程序的运行时间。
   > 
   > 另一方面，算法复杂度比计算步数更进一步，它无须精确计算程序的步数 —— 算法复杂度考虑的是增长速度的快慢：比如说，当我们说一个算法 A 的复杂度比另一个算法 B 的复杂度要高的时候，意思是说，算法 A 计算所需的资源（时间或空间）要比算法 B 要多。
   > 
   > 一般来说，复杂度更低的算法，实际的运行速度总比一个复杂度更高的算法要来得更快，有时候在输入比较小时会比较难看出差别，但是当**输入变得越来越大的时候，低复杂度算法的优势就会体现出来**。

6. 以过程作为参数，或者以过程作为返回值。这类能操作过程的过程称为**高阶过程**。

7. lambda过程如何得名
   
   > 对于学习Lisp的人而言，如果用一个比lambda更明确的名字，如make-procedure，可能会觉得更清楚。但是习惯成自然，这一记法形式取自演算，那是由数理逻辑学家丘奇 (Alonzo Church 1941)引进的一种数学记法，为研究函数和函数应用提供一个严格的基础。$\lambda$演算已经成为程序设计语言语义的数学基石。
