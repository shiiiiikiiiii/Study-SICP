1. 简单理解解释器的作用方式--代换模型
   
   > 将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。
   > 
   > 这里的代换模型只是这些模型中的第一个一一作为形式化地考虑这种求值过程的起点。一般来说，在模拟科学研究或者工程中的现象时，我们总是从最简单的不完全的模型开始。随着更细致地检查所考虑的问题，这些简单模型也会变得越来越不合适，从而必须用进一步精化的模型取代。

2. 两种求值模型--正则序求值/应用序求值
   
   > “完全展开而后归约”的求值模型称为正则序求值，与之对应的是现在解释器里实际使用的“先求值参数而后应用”的方式，它称为应用序求值。

3. Lisp命名规范--函数命名时用`-`划分
   
   > 给Scheme函数命名使用-划分的原因有以下几点:
   > 
   > 1. Scheme语言对标识符的命名非常灵活,允许使用特殊字符如-。
   > 2. Lisp家族语言fromString建议用-而不是_来连接多词标识符。
   > 3. -比_更容易辨认,a-plus-b比a_plus_b更易读。
   > 4. Scheme本身语法就包含-,如define-syntax。
   > 5. 使用-符合Scheme、Lisp传统和习惯。

4. 线性迭代--只维护有限数量的状态
   
   > ```scheme
   > (define (fib n)
   >   (fib-iter 1 0 n))
   > 
   > (define (fib-iter a b count)
   >   (if (= count 0)
   >       b
   >       (fib-iter (+ a b) a (- count 1))))
   > ```
   > 
   > 为什么这个代码中的 `fib-iter` 函数被称为线性迭代：
   > 
   > 1. `fib-iter` 函数是一个带有三个参数的迭代函数，其中 `a` 和 `b` 分别表示斐波那契数列的前两个元素，`count` 表示还需要计算多少个斐波那契数。
   > 
   > 2. 在每次迭代中，`fib-iter` 函数计算下一个斐波那契数（`a + b`），并将 `a` 更新为之前的 `b`，将 `b` 更新为之前的计算结果。这就是为什么它被称为线性迭代，因为它在每次迭代中只需要维护两个状态（`a` 和 `b`），而不需要创建额外的递归调用堆栈。
   > 
   > 3. 当 `count` 减小到零时，迭代停止，返回最终的结果 `b`。这是一个迭代终止条件。
   > 
   > 所以，尽管 `fib-iter` 函数使用了函数递归（在每次迭代中调用自己），但它被称为线性迭代，因为它只维护了有限数量的状态，而没有创建大量的递归函数调用帧，这符合线性迭代的特性。这种方法通常比直接使用递归更有效率，因为不需要大量的函数调用开销。

5. 
